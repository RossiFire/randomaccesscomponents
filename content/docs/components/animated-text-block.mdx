---
title: Reveal Text
description: Smooth animated text reveal with GSAP
hot_item: true
---

<PageBadge badges={[ 'gsap', 'tailwind' ]} />


## Demo

<PreviewCodeBlock preview={<RevealTextDemo />}>
    ```tsx
  import { RevealText, RevealTextLine } from "./animated-text-block";
  import type { RevealTextHandle } from "./animated-text-block";

  const Demo: React.FC = () => {
    const ref = useRef<RevealTextHandle>(null);
    const [animating, setAnimating] = useState(false);

    return (
      <RevealText
        ref={ref}
        lines={[<RevealTextLine className="bg-accent" key="0" />]}
        className="text-4xl font-bold uppercase text-center leading-tight"
      >
        <strong className="text-accent">REDEFINING</strong> WEB, CHASING
        <strong className="text-accent">PERFORMANCE</strong>, BRINGING IT ALL IN ALL WAYS. DEFINING A
        <strong className="text-accent">STANDARD</strong> WITH RUI ON AND OFF THE WEB.
      </RevealText>

      <button
        onClick={() => ref.current?.play({
          onStart: () => setAnimating(true),
          onComplete: () => setAnimating(false),
        })}
        disabled={animating}
      >
        {animating ? "Animating..." : "Run animation"}
      </button>
    );
  };
    ```
</PreviewCodeBlock>

## Installation

<PkgInstallerTabs command="gsap @gsap/react" />


Copy and paste the following code into your project.


```tsx title="reveal-text.tsx" icon="react"
"use client";
import gsap from "gsap";
import { SplitText } from "gsap/SplitText";
import { cn } from "@/lib/utils";
import * as React from "react";
import { useGSAP } from "@gsap/react";

gsap.registerPlugin(SplitText);

type RevealTextHandle = {
    play: (timelineVars?: gsap.TimelineVars) => gsap.core.Timeline;
    reset: () => void;
    element: HTMLDivElement | null;
};

function createDefaultLineReveal(): HTMLDivElement {
    const div = document.createElement("div");
    div.className = "high-line-reveal absolute bottom-0 left-0 w-full h-full bg-accent will-change-transform origin-[right_center]";
    return div;
}

function splitAndPrepare(
    container: HTMLElement,
    linesContainer: HTMLElement | null,
    startVisible: boolean
) {
    const targets = gsap.utils.toArray(
        container.querySelectorAll('[data-slot="reveal-text-content"]')
    ) as HTMLElement[];

    const templates = linesContainer
        ? (Array.from(linesContainer.children) as HTMLElement[])
        : [];

    targets.forEach(target => {
        const split = new SplitText(target, { type: "lines", aria: "none" });
        split.lines.forEach((line, i) => {
            line.classList.add("faded-text", "relative", "w-fit", "mx-auto");

            if (templates.length > 0) {
                const reveal = templates[i % templates.length].cloneNode(true) as HTMLElement;
                reveal.classList.add("high-line-reveal");
                Object.assign(reveal.style, {
                    position: "absolute",
                    bottom: "0",
                    left: "0",
                    width: "100%",
                    height: "100%",
                    willChange: "transform",
                    transformOrigin: "right center",
                });
                line.appendChild(reveal);
            } else {
                line.appendChild(createDefaultLineReveal());
            }
        });

        if (!startVisible) {
            gsap.set(split.lines, { clipPath: "inset(0 100% 0px 0px)" });
        }
    });

    gsap.set(container.querySelectorAll(".high-line-reveal"), {
        scaleX: startVisible ? 0 : 1,
    });
}

function resetState(container: HTMLElement) {
    gsap.set(container.querySelectorAll(".faded-text"), { clipPath: "inset(0 100% 0px 0px)" });
    gsap.set(container.querySelectorAll(".high-line-reveal"), { scaleX: 1 });
}

function RevealText({
    children,
    className,
    startVisible = false,
    lines = [],
    textAnimation,
    revealAnimation,
    ref,
    ...props
}: Omit<React.ComponentProps<"div">, "ref"> & {
    startVisible?: boolean;
    lines?: React.ReactNode[];
    textAnimation?: gsap.TweenVars;
    revealAnimation?: gsap.TweenVars & { at?: string };
    ref?: React.Ref<RevealTextHandle>;
}) {
    const containerRef = React.useRef<HTMLDivElement>(null);
    const linesRef = React.useRef<HTMLDivElement>(null);

    useGSAP(() => {
        if (!containerRef.current) return;
        splitAndPrepare(containerRef.current, linesRef.current, startVisible);
    });

    React.useImperativeHandle(ref, () => {
        const play = (timelineVars?: gsap.TimelineVars) => {
            if (!containerRef.current) return gsap.timeline();
            resetState(containerRef.current);

            const fadedTexts = containerRef.current.querySelectorAll(".faded-text");
            const reveals = containerRef.current.querySelectorAll(".high-line-reveal");
            const { at, ...revealVars } = revealAnimation ?? {};

            return gsap.timeline(timelineVars)
                .to(fadedTexts, {
                    clipPath: "inset(0px 0% 0px 0px)",
                    duration: 0.6,
                    stagger: 0.2,
                    ease: "power2.inOut",
                    ...textAnimation,
                })
                .to(reveals, {
                    scaleX: 0,
                    duration: 0.6,
                    stagger: 0.2,
                    ease: "power4.inOut",
                    ...revealVars,
                }, at ?? "<20%");
        };

        const reset = () => {
            if (containerRef.current) resetState(containerRef.current);
        };

        return {
            play,
            reset,
            get element() { return containerRef.current; },
        };
    });

    return (
        <div
            data-slot="reveal-text"
            className={cn("relative", className)}
            {...props}
        >
            <p data-slot="reveal-text-content" className="par">
                {children}
            </p>
            {lines.length > 0 && (
                <div ref={linesRef} className="hidden" aria-hidden="true">
                    {lines}
                </div>
            )}
        </div>
    );
}
RevealText.displayName = "RevealText";

function RevealTextLine({
    className,
    ...props
}: React.ComponentProps<"div">) {
    return (
        <div
            data-slot="reveal-text-line"
            className={cn("bg-accent", className)}
            {...props}
        />
    );
}
RevealTextLine.displayName = "RevealTextLine";

export { RevealText, RevealTextLine, resetState };
export type { RevealTextHandle };
```

## Usage

### Basic

Pass any text or `ReactNode` as children. Inline elements like `<strong>`, `<em>`, or `<span>` are fully supported.

```tsx title="page.tsx" icon="react"
const ref = useRef<RevealTextHandle>(null);

<RevealText ref={ref}>
    I'm a text that will be revealed.
</RevealText>

<button onClick={() => ref.current?.play()}>Animate</button>
```

### Triggering the animation

The `ref` exposes a `play()` method that resets state and animates. It accepts optional `gsap.TimelineVars` (e.g. `onStart`, `onComplete`, `scrollTrigger`):

```tsx title="page.tsx" icon="react"
const ref = useRef<RevealTextHandle>(null);

ref.current?.play({
    onStart: () => console.log("started"),
    onComplete: () => console.log("done"),
});
```

### Custom animation timing

Use `textAnimation` and `revealAnimation` to override the default GSAP tween vars. Defaults are merged — you only need to specify the properties you want to change.

```tsx title="page.tsx" icon="react"
// Faster text with slower overlay
<RevealText
    ref={ref}
    textAnimation={{ duration: 0.8, stagger: 0.05, ease: "power2.out" }}
    revealAnimation={{ duration: 0.8, stagger: 0.05 }}
>
    Your text here.
</RevealText>

// Change the reveal timeline position (default is "<20%")
<RevealText
    ref={ref}
    revealAnimation={{ at: "<50%" }}
>
    Different reveal offset.
</RevealText>
```

### Custom line reveals

Pass an array of `RevealTextLine` elements via `lines`. Cycles if fewer than text lines, slices extras.

```tsx title="page.tsx" icon="react"
// Single color — applied to every line
<RevealText lines={[<RevealTextLine className="bg-red-500" key="0" />]}>
    Your text here.
</RevealText>

// Alternating colors
<RevealText
    lines={[
        <RevealTextLine className="bg-red-500" key="0" />,
        <RevealTextLine className="bg-blue-500" key="1" />,
    ]}
>
    Lines alternate between red and blue reveals.
</RevealText>
```

When no `lines` are passed, a default `bg-accent` reveal is used.

### With `startVisible`

By default, text is hidden until the animation plays. Set `startVisible` to render text immediately.

```tsx title="page.tsx" icon="react"
<RevealText startVisible>
    This text is visible on mount.
</RevealText>
```

### With `ScrollTrigger`

```tsx title="page.tsx" icon="react"
import { ScrollTrigger } from "gsap/ScrollTrigger";

gsap.registerPlugin(SplitText, ScrollTrigger);
```

Pass `scrollTrigger` inside the `play()` timeline vars:

```tsx title="page.tsx" icon="react"
const ref = useRef<RevealTextHandle>(null);

useGSAP(() => {
    if (!ref.current) return;
    ref.current.play({
        scrollTrigger: {
            trigger: ref.current.element,
            start: "top 70%",
        },
    });
});

return (
    <RevealText ref={ref} className="text-4xl font-bold">
        This text reveals <strong>on scroll</strong>.
    </RevealText>
)
```

## API Reference

### RevealText

The root container. Handles `SplitText` splitting, line reveal injection, and exposes `play()`/`reset()` via ref.

| Prop | Type | Default | Description |
| --- | --- | --- | --- |
| `children` | `ReactNode` | — | Text content. Supports inline elements like `<strong>`, `<em>`, `<span>`. |
| `startVisible` | `boolean` | `false` | When `true`, text is visible immediately. |
| `lines` | `ReactNode[]` | `[]` | Custom line reveals. Cycles if fewer than text lines, slices extras. |
| `textAnimation` | `gsap.TweenVars` | `{ clipPath, duration: 0.6, stagger: 0.2, ease: "power2.inOut" }` | Overrides for the text clip-path animation. |
| `revealAnimation` | `gsap.TweenVars & { at?: string }` | `{ scaleX: 0, duration: 0.6, stagger: 0.2, ease: "power4.inOut", at: "<20%" }` | Overrides for the reveal overlay animation. `at` sets the timeline position. |
| `className` | `string` | — | CSS classes for the container. Text styling classes inherit to children. |
| `ref` | `Ref<RevealTextHandle>` | — | Imperative handle with `play()`, `reset()`, and `element`. |

### RevealTextHandle

Imperative handle exposed via `ref`.

| Method | Signature | Description |
| --- | --- | --- |
| `play` | `(timelineVars?: gsap.TimelineVars) => gsap.core.Timeline` | Resets state and plays the animation. Pass `scrollTrigger`, `onStart`, `onComplete`, etc. |
| `reset` | `() => void` | Resets animation to initial hidden state. |
| `element` | `HTMLDivElement \| null` | The container DOM element, for `ScrollTrigger` triggers or DOM queries. |

### RevealTextLine

A customizable reveal overlay element, used in the `lines` array.

| Prop | Type | Default | Description |
| --- | --- | --- | --- |
| `className` | `string` | — | Visual styling (background, gradient, etc). Defaults to `bg-accent`. |

## Techbook

I want to take a moment to focus on some concepts about this component.

When working with animations, finding the right combination of **timing** and **easing** to make the animation looks smooth and natural is the key.
You also need to consider the context where the animation is going to be used.

For example, this is an alternative implementation with a different timing and easing.

<Tabs items={['demo', 'animation']}>
    <Tab value="demo" className="p-0">
        <RevealTextAlternativeDemo />
    </Tab>
    <Tab value="animation">
    ```tsx
    <RevealText
        textAnimation={{ duration: 0.8, stagger: 0.05, ease: "power2.out" }}
        revealAnimation={{ duration: 0.8, stagger: 0.05 }}
    >
        ...
    </RevealText>
    ```
    </Tab>
</Tabs>

And If it seems a bit awkward, maybe it has just a wrong timing, like this one:


<Tabs items={['demo', 'animation']}>
    <Tab value="demo" className="p-0">
        <RevealTextWrongDemo />
    </Tab>
    <Tab value="animation">
    ```tsx
    <RevealText
        textAnimation={{ duration: 0.3, stagger: 0.05, ease: "sine.inOut" }}
        revealAnimation={{ duration: 1, stagger: 0.2 }}
    >
        ...
    </RevealText>
    ```
    </Tab>
</Tabs>

This is something that goes beyond the library to use or the component itself, it's a matter of trial and error. 
So don't be scared to experiment and find the right timing for your specific use case!
